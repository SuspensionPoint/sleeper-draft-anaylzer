/* tslint:disable */
/* eslint-disable */
/**
 * Sleeper API
 * The Sleeper API is a read-only HTTP API that is free to use and allows             access to a users leagues, drafts, and rosters. No API Token is necessary, as you cannot modify contents via this API. Be mindful of the frequency of calls. A general rule is to stay under 1000 API calls per minute, otherwise, you risk being IP-blocked.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Draft
 */
export interface Draft {
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    status: string;
    /**
     * 
     * @type {number}
     * @memberof Draft
     */
    start_time: number;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    sport: string;
    /**
     * 
     * @type {DraftSettings}
     * @memberof Draft
     */
    settings: DraftSettings;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    season_type: string;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    season: string;
    /**
     * 
     * @type {DraftMetadata}
     * @memberof Draft
     */
    metadata: DraftMetadata;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    league_id: string;
    /**
     * 
     * @type {number}
     * @memberof Draft
     */
    last_picked: number;
    /**
     * 
     * @type {number}
     * @memberof Draft
     */
    last_message_time: number;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    last_message_id: string;
    /**
     * this is the user_id to draft slot mapping
     * @type {{ [key: string]: number; }}
     * @memberof Draft
     */
    draft_order: { [key: string]: number; } | null;
    /**
     * this is the draft slot to roster_id mapping. leagues have rosters, which have roster_ids. this means draft slot 1 (column 1) will go to roster 10, slot 2 will go to roster_id 3, etc
     * @type {{ [key: string]: number; }}
     * @memberof Draft
     */
    slot_to_roster_id?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    draft_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Draft
     */
    creators: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof Draft
     */
    created: number;
}
/**
 * 
 * @export
 * @interface DraftMetadata
 */
export interface DraftMetadata {
    /**
     * 
     * @type {string}
     * @memberof DraftMetadata
     */
    scoring_type: string;
    /**
     * 
     * @type {string}
     * @memberof DraftMetadata
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DraftMetadata
     */
    description: string;
}
/**
 * picks that were traded
 * @export
 * @interface DraftPick
 */
export interface DraftPick {
    /**
     * the season this draft pick belongs to
     * @type {string}
     * @memberof DraftPick
     */
    season: string;
    /**
     * which round this draft pick is
     * @type {number}
     * @memberof DraftPick
     */
    round: number;
    /**
     * original owner\'s roster_id
     * @type {number}
     * @memberof DraftPick
     */
    roster_id: number;
    /**
     * previous owner\'s roster id (in this trade)
     * @type {number}
     * @memberof DraftPick
     */
    previous_owner_id: number;
    /**
     * the new owner of this pick after the trade
     * @type {number}
     * @memberof DraftPick
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface DraftSettings
 */
export interface DraftSettings {
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    teams: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_wr: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_te: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_rb: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_qb: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_k: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_flex: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_def: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    slots_bn: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    rounds: number;
    /**
     * 
     * @type {number}
     * @memberof DraftSettings
     */
    pick_timer: number;
}
/**
 * 
 * @export
 * @interface League
 */
export interface League {
    /**
     * 
     * @type {number}
     * @memberof League
     */
    total_rosters: number;
    /**
     * can also be \"drafting\", \"in_season\", or \"complete\";
     * @type {string}
     * @memberof League
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    sport: string;
    /**
     * 
     * @type {LeagueSettings}
     * @memberof League
     */
    settings: LeagueSettings;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    season_type: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    season: string;
    /**
     * 
     * @type {ScoreingSettings}
     * @memberof League
     */
    scoring_settings: ScoreingSettings;
    /**
     * 
     * @type {Array<string>}
     * @memberof League
     */
    roster_positions: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    previous_league_id: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    league_id: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    draft_id: string;
    /**
     * 
     * @type {string}
     * @memberof League
     */
    avatar: string;
}
/**
 * 
 * @export
 * @interface LeagueSettings
 */
export interface LeagueSettings {
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    max_keepers: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    draft_rounds: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    trade_review_days: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_dnr: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    capacity_override: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    pick_trading: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    taxi_years: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    taxi_allow_vets: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    disable_adds: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    waiver_type: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    bench_lock: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_sus: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    type: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_cov: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    waiver_clear_days: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    waiver_day_of_week: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    playoff_teams: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    num_teams: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_slots: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    playoff_round_type: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    daily_waivers_hour: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    waiver_budget: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_out: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    offseason_adds: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    playoff_seed_type: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    daily_waivers: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    playoff_week_start: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    league_average_match: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    leg: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    trade_deadline: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_doubtful: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    taxi_deadline: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    reserve_allow_na: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    taxi_slots: number;
    /**
     * 
     * @type {number}
     * @memberof LeagueSettings
     */
    playoff_type: number;
}
/**
 * 
 * @export
 * @interface Matchup
 */
export interface Matchup {
    /**
     * 
     * @type {Array<string>}
     * @memberof Matchup
     */
    starters: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Matchup
     */
    roster_id: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Matchup
     */
    players: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Matchup
     */
    matchup_id: number;
    /**
     * 
     * @type {number}
     * @memberof Matchup
     */
    points: number;
    /**
     * 
     * @type {number}
     * @memberof Matchup
     */
    custom_points: number | null;
}
/**
 * 
 * @export
 * @interface Pick
 */
export interface Pick {
    /**
     * 
     * @type {string}
     * @memberof Pick
     */
    player_id: string;
    /**
     * user_id this pick will go to (not all leagues have users in every slot, this can be \"\"
     * @type {string}
     * @memberof Pick
     */
    picked_by: string;
    /**
     * roster_id this pick will go to
     * @type {string}
     * @memberof Pick
     */
    roster_id: string;
    /**
     * 
     * @type {number}
     * @memberof Pick
     */
    round: number;
    /**
     * which column this is on the draftboard
     * @type {number}
     * @memberof Pick
     */
    draft_slot: number;
    /**
     * 
     * @type {number}
     * @memberof Pick
     */
    pick_no: number;
    /**
     * 
     * @type {PickMetadata}
     * @memberof Pick
     */
    metadata: PickMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof Pick
     */
    is_keeper: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Pick
     */
    draft_id: string;
}
/**
 * 
 * @export
 * @interface PickMetadata
 */
export interface PickMetadata {
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    team: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    sport: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    position: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    player_id: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    number: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    news_updated: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    injury_status: string;
    /**
     * 
     * @type {string}
     * @memberof PickMetadata
     */
    first_name: string;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    hashtag: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    depth_chart_position: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    sport: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Player
     */
    fantasy_positions: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    number: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    search_last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    injury_start_date: string | null;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    weight: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    position: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    practice_participation: string | null;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    sportradar_id: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    team: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    last_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    college: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    fantasy_data_id: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    injury_status: string | null;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    player_id: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    height: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    search_full_name: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    age: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    stats_id: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    birth_country: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    espn_id: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    search_rank: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    first_name: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    depth_chart_order: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    years_exp: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    rotowire_id: string | null;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    rotoworld_id: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    search_first_name: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    yahoo_id: string | null;
}
/**
 * 
 * @export
 * @interface Roster
 */
export interface Roster {
    /**
     * 
     * @type {Array<string>}
     * @memberof Roster
     */
    starters: Array<string>;
    /**
     * 
     * @type {RosterSettings}
     * @memberof Roster
     */
    settings: RosterSettings;
    /**
     * 
     * @type {number}
     * @memberof Roster
     */
    roster_id: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Roster
     */
    reserve: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Roster
     */
    players: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Roster
     */
    owner_id: string;
    /**
     * 
     * @type {string}
     * @memberof Roster
     */
    league_id: string;
}
/**
 * 
 * @export
 * @interface RosterSettings
 */
export interface RosterSettings {
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    wins: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    waiver_position: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    waiver_budget_used: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    total_moves: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    ties: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    losses: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    fpts_decimal: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    fpts_against_decimal: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    fpts_against: number;
    /**
     * 
     * @type {number}
     * @memberof RosterSettings
     */
    fpts: number;
}
/**
 * 
 * @export
 * @interface ScoreingSettings
 */
export interface ScoreingSettings {
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pass_2pt: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pass_int: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgmiss: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rec_yd: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    xpmiss: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgm_30_39: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    blk_kick: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_7_13: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    ff: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgm_20_29: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgm_40_49: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_1_6: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    st_fum_rec: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    def_st_ff: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    st_ff: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_28_34: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgm_50p: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fum_rec: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    def_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fgm_0_19: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    _int: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_0: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_21_27: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rec_2pt: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rec: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    xpm: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    st_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    def_st_fum_rec: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    def_st_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    sack: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fum_rec_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rush_2pt: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rec_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_35p: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pts_allow_14_20: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rush_yd: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pass_yd: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    pass_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    rush_td: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fum_lost: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    fum: number;
    /**
     * 
     * @type {number}
     * @memberof ScoreingSettings
     */
    safe: number;
}
/**
 * 
 * @export
 * @interface SportState
 */
export interface SportState {
    /**
     * week
     * @type {number}
     * @memberof SportState
     */
    week: number;
    /**
     * pre, post, regular
     * @type {string}
     * @memberof SportState
     */
    season_type: SportStateSeasonTypeEnum;
    /**
     * regular season start
     * @type {string}
     * @memberof SportState
     */
    season_start_date: string;
    /**
     * current season
     * @type {string}
     * @memberof SportState
     */
    season: string;
    /**
     * previous season
     * @type {string}
     * @memberof SportState
     */
    previous_season: string;
    /**
     * week of regular season
     * @type {number}
     * @memberof SportState
     */
    leg: number;
    /**
     * active season for leagues
     * @type {string}
     * @memberof SportState
     */
    league_season: string;
    /**
     * flips in December
     * @type {string}
     * @memberof SportState
     */
    league_create_season: string;
    /**
     * Which week to display in UI, can be different than week
     * @type {number}
     * @memberof SportState
     */
    display_week: number;
}

/**
    * @export
    * @enum {string}
    */
export enum SportStateSeasonTypeEnum {
    Pre = 'pre',
    Post = 'post',
    Regular = 'regular'
}

/**
 * 
 * @export
 * @interface TradedPick
 */
export interface TradedPick {
    /**
     * which season the pick is for
     * @type {string}
     * @memberof TradedPick
     */
    season: string;
    /**
     * which round the pick is
     * @type {number}
     * @memberof TradedPick
     */
    round: number;
    /**
     * roster_id of ORIGINAL owner
     * @type {number}
     * @memberof TradedPick
     */
    roster_id: number;
    /**
     * roster_id of the previous owner
     * @type {number}
     * @memberof TradedPick
     */
    previous_owner_id: number;
    /**
     * roster_id of current owner
     * @type {number}
     * @memberof TradedPick
     */
    owner_id: number;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    transaction_id: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    status_updated: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    status: string;
    /**
     * Trades do not use this field
     * @type {object}
     * @memberof Transaction
     */
    settings: object | null;
    /**
     * roster_ids involved in this transaction
     * @type {Array<number>}
     * @memberof Transaction
     */
    roster_ids: Array<number>;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    metadata: object | null;
    /**
     * in football, this is the week
     * @type {number}
     * @memberof Transaction
     */
    leg: number;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    drops: object;
    /**
     * 
     * @type {Array<DraftPick>}
     * @memberof Transaction
     */
    draft_picks: Array<DraftPick>;
    /**
     * user id who initiated the transaction
     * @type {string}
     * @memberof Transaction
     */
    creator: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    created: number;
    /**
     * roster_ids of the people who agreed to this transaction
     * @type {Array<number>}
     * @memberof Transaction
     */
    consenter_ids: Array<number>;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    adds: object | null;
    /**
     * 
     * @type {Array<WaiverBudget>}
     * @memberof Transaction
     */
    waiver_budget: Array<WaiverBudget>;
}
/**
 * 
 * @export
 * @interface TrendingPlayer
 */
export interface TrendingPlayer {
    /**
     * the player_id
     * @type {string}
     * @memberof TrendingPlayer
     */
    player_id: string;
    /**
     * number or adds
     * @type {number}
     * @memberof TrendingPlayer
     */
    count: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    user_id: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatar: string;
}
/**
 * 
 * @export
 * @interface UserInLeague
 */
export interface UserInLeague {
    /**
     * 
     * @type {string}
     * @memberof UserInLeague
     */
    user_id: string;
    /**
     * 
     * @type {string}
     * @memberof UserInLeague
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInLeague
     */
    display_name: string;
    /**
     * 
     * @type {string}
     * @memberof UserInLeague
     */
    avatar: string;
    /**
     * 
     * @type {UserInLeagueMetadata}
     * @memberof UserInLeague
     */
    metadata: UserInLeagueMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof UserInLeague
     */
    is_owner: boolean;
}
/**
 * 
 * @export
 * @interface UserInLeagueMetadata
 */
export interface UserInLeagueMetadata {
    /**
     * 
     * @type {string}
     * @memberof UserInLeagueMetadata
     */
    team_name: string;
}
/**
 * roster_id 2 sends 55 FAAB dollars to roster_id 3
 * @export
 * @interface WaiverBudget
 */
export interface WaiverBudget {
    /**
     * 
     * @type {number}
     * @memberof WaiverBudget
     */
    sender: number;
    /**
     * 
     * @type {number}
     * @memberof WaiverBudget
     */
    receiver: number;
    /**
     * 
     * @type {number}
     * @memberof WaiverBudget
     */
    amount: number;
}

/**
 * AvatarsApi - axios parameter creator
 * @export
 */
export const AvatarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a full size avatar image
         * @summary Get an avatar
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsAvatarIdGet: async (avatarId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('avatarsAvatarIdGet', 'avatarId', avatarId)
            const localVarPath = `/avatars/{avatarId}`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a thumbnail for the avatar
         * @summary Get an avatar thumbnail
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsThumbsAvatarIdGet: async (avatarId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatarId' is not null or undefined
            assertParamExists('avatarsThumbsAvatarIdGet', 'avatarId', avatarId)
            const localVarPath = `/avatars/thumbs/{avatarId}`
                .replace(`{${"avatarId"}}`, encodeURIComponent(String(avatarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvatarsApi - functional programming interface
 * @export
 */
export const AvatarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvatarsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a full size avatar image
         * @summary Get an avatar
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsAvatarIdGet(avatarId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avatarsAvatarIdGet(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a thumbnail for the avatar
         * @summary Get an avatar thumbnail
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avatarsThumbsAvatarIdGet(avatarId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avatarsThumbsAvatarIdGet(avatarId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AvatarsApi - factory interface
 * @export
 */
export const AvatarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvatarsApiFp(configuration)
    return {
        /**
         * Get a full size avatar image
         * @summary Get an avatar
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsAvatarIdGet(avatarId: string, options?: any): AxiosPromise<void> {
            return localVarFp.avatarsAvatarIdGet(avatarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a thumbnail for the avatar
         * @summary Get an avatar thumbnail
         * @param {string} avatarId The avatar id to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avatarsThumbsAvatarIdGet(avatarId: string, options?: any): AxiosPromise<void> {
            return localVarFp.avatarsThumbsAvatarIdGet(avatarId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvatarsApi - object-oriented interface
 * @export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
export class AvatarsApi extends BaseAPI {
    /**
     * Get a full size avatar image
     * @summary Get an avatar
     * @param {string} avatarId The avatar id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsAvatarIdGet(avatarId: string, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsAvatarIdGet(avatarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a thumbnail for the avatar
     * @summary Get an avatar thumbnail
     * @param {string} avatarId The avatar id to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    public avatarsThumbsAvatarIdGet(avatarId: string, options?: any) {
        return AvatarsApiFp(this.configuration).avatarsThumbsAvatarIdGet(avatarId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DraftsApi - axios parameter creator
 * @export
 */
export const DraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdGet: async (draftId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftDraftIdGet', 'draftId', draftId)
            const localVarPath = `/draft/{draftId}`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdPicksGet: async (draftId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftDraftIdPicksGet', 'draftId', draftId)
            const localVarPath = `/draft/{draftId}/picks`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdTradedPicksGet: async (draftId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftDraftIdTradedPicksGet', 'draftId', draftId)
            const localVarPath = `/draft/{draftId}/traded_picks`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all drafts for a league. Keep in mind that a league can have multiple drafts, especially dynasty leagues. Drafts are sorted by most recent to earliest. Most leagues should only have one draft.
         * @summary Get all drafts for a league
         * @param {string} leagueId The ID of the league for which you are trying to retrieve drafts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdDraftsGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdDraftsGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/drafts`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all drafts by a user.
         * @summary Get all drafts for user
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdDraftsSportSeasonGet: async (userId: string, sport: string, season: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userUserIdDraftsSportSeasonGet', 'userId', userId)
            // verify required parameter 'sport' is not null or undefined
            assertParamExists('userUserIdDraftsSportSeasonGet', 'sport', sport)
            // verify required parameter 'season' is not null or undefined
            assertParamExists('userUserIdDraftsSportSeasonGet', 'season', season)
            const localVarPath = `/user/{userId}/drafts/{sport}/{season}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"sport"}}`, encodeURIComponent(String(sport)))
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DraftsApi - functional programming interface
 * @export
 */
export const DraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftDraftIdGet(draftId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Draft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftDraftIdGet(draftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftDraftIdPicksGet(draftId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pick>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftDraftIdPicksGet(draftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftDraftIdTradedPicksGet(draftId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradedPick>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftDraftIdTradedPicksGet(draftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all drafts for a league. Keep in mind that a league can have multiple drafts, especially dynasty leagues. Drafts are sorted by most recent to earliest. Most leagues should only have one draft.
         * @summary Get all drafts for a league
         * @param {string} leagueId The ID of the league for which you are trying to retrieve drafts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdDraftsGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Draft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdDraftsGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all drafts by a user.
         * @summary Get all drafts for user
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUserIdDraftsSportSeasonGet(userId: string, sport: string, season: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Draft>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUserIdDraftsSportSeasonGet(userId, sport, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DraftsApi - factory interface
 * @export
 */
export const DraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DraftsApiFp(configuration)
    return {
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdGet(draftId: string, options?: any): AxiosPromise<Array<Draft>> {
            return localVarFp.draftDraftIdGet(draftId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdPicksGet(draftId: string, options?: any): AxiosPromise<Array<Pick>> {
            return localVarFp.draftDraftIdPicksGet(draftId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a specific draft.
         * @summary Get a specific draft
         * @param {string} draftId The ID of the draft to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftDraftIdTradedPicksGet(draftId: string, options?: any): AxiosPromise<Array<TradedPick>> {
            return localVarFp.draftDraftIdTradedPicksGet(draftId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all drafts for a league. Keep in mind that a league can have multiple drafts, especially dynasty leagues. Drafts are sorted by most recent to earliest. Most leagues should only have one draft.
         * @summary Get all drafts for a league
         * @param {string} leagueId The ID of the league for which you are trying to retrieve drafts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdDraftsGet(leagueId: string, options?: any): AxiosPromise<Array<Draft>> {
            return localVarFp.leagueLeagueIdDraftsGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all drafts by a user.
         * @summary Get all drafts for user
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdDraftsSportSeasonGet(userId: string, sport: string, season: number, options?: any): AxiosPromise<Array<Draft>> {
            return localVarFp.userUserIdDraftsSportSeasonGet(userId, sport, season, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DraftsApi - object-oriented interface
 * @export
 * @class DraftsApi
 * @extends {BaseAPI}
 */
export class DraftsApi extends BaseAPI {
    /**
     * This endpoint retrieves a specific draft.
     * @summary Get a specific draft
     * @param {string} draftId The ID of the draft to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public draftDraftIdGet(draftId: string, options?: any) {
        return DraftsApiFp(this.configuration).draftDraftIdGet(draftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a specific draft.
     * @summary Get a specific draft
     * @param {string} draftId The ID of the draft to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public draftDraftIdPicksGet(draftId: string, options?: any) {
        return DraftsApiFp(this.configuration).draftDraftIdPicksGet(draftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a specific draft.
     * @summary Get a specific draft
     * @param {string} draftId The ID of the draft to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public draftDraftIdTradedPicksGet(draftId: string, options?: any) {
        return DraftsApiFp(this.configuration).draftDraftIdTradedPicksGet(draftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all drafts for a league. Keep in mind that a league can have multiple drafts, especially dynasty leagues. Drafts are sorted by most recent to earliest. Most leagues should only have one draft.
     * @summary Get all drafts for a league
     * @param {string} leagueId The ID of the league for which you are trying to retrieve drafts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public leagueLeagueIdDraftsGet(leagueId: string, options?: any) {
        return DraftsApiFp(this.configuration).leagueLeagueIdDraftsGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all drafts by a user.
     * @summary Get all drafts for user
     * @param {string} userId the user is to get
     * @param {string} sport Only \&quot;nfl\&quot; is supported right now
     * @param {number} season The NFL season to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public userUserIdDraftsSportSeasonGet(userId: string, sport: string, season: number, options?: any) {
        return DraftsApiFp(this.configuration).userUserIdDraftsSportSeasonGet(userId, sport, season, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeaguesApi - axios parameter creator
 * @export
 */
export const LeaguesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all leagues.
         * @summary Get a specific league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the loosers playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdLosesBracketGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdLosesBracketGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/loses_bracket`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all matchups in a league for a given week. Each object in the list represents one team. The two teams with the same matchup_id match up against each other. The starters is in an ordered list of player_ids, and players is a list of all player_ids in this matchup. The bench can be deduced by removing the starters from the players field.
         * @summary Getting matchups in a league
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} week The week these matchups take place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdMatchupsWeekGet: async (leagueId: string, week: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdMatchupsWeekGet', 'leagueId', leagueId)
            // verify required parameter 'week' is not null or undefined
            assertParamExists('leagueLeagueIdMatchupsWeekGet', 'week', week)
            const localVarPath = `/league/{leagueId}/matchups/{week}`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)))
                .replace(`{${"week"}}`, encodeURIComponent(String(week)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all rosters in a league.
         * @summary Getting rosters in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdRostersGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdRostersGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/rosters`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get traded picks
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdTradedPicksGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdTradedPicksGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/traded_picks`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Get Transactions
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} round The week you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdTransactionsRoundGet: async (leagueId: string, round: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdTransactionsRoundGet', 'leagueId', leagueId)
            // verify required parameter 'round' is not null or undefined
            assertParamExists('leagueLeagueIdTransactionsRoundGet', 'round', round)
            const localVarPath = `/league/{leagueId}/transactions/{round}`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)))
                .replace(`{${"round"}}`, encodeURIComponent(String(round)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all users in a league. This also includes each users display_name, avatar, and their metadata which sometimes includes a nickname they gave their team.
         * @summary Getting users in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdUsersGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdUsersGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/users`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the winners playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdWinnersBracketGet: async (leagueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leagueId' is not null or undefined
            assertParamExists('leagueLeagueIdWinnersBracketGet', 'leagueId', leagueId)
            const localVarPath = `/league/{leagueId}/winners_bracket`
                .replace(`{${"leagueId"}}`, encodeURIComponent(String(leagueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get NFL State
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateSportGet: async (sport: 'nfl' | 'nba' | 'lcs', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sport' is not null or undefined
            assertParamExists('stateSportGet', 'sport', sport)
            const localVarPath = `/state/{sport}`
                .replace(`{${"sport"}}`, encodeURIComponent(String(sport)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint retrieves all leagues.
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdLeaguesSportSeasonGet: async (userId: string, sport: string, season: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userUserIdLeaguesSportSeasonGet', 'userId', userId)
            // verify required parameter 'sport' is not null or undefined
            assertParamExists('userUserIdLeaguesSportSeasonGet', 'sport', sport)
            // verify required parameter 'season' is not null or undefined
            assertParamExists('userUserIdLeaguesSportSeasonGet', 'season', season)
            const localVarPath = `/user/{userId}/leagues/{sport}/{season}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"sport"}}`, encodeURIComponent(String(sport)))
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaguesApi - functional programming interface
 * @export
 */
export const LeaguesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaguesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint retrieves all leagues.
         * @summary Get a specific league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<League>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the loosers playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdLosesBracketGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdLosesBracketGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all matchups in a league for a given week. Each object in the list represents one team. The two teams with the same matchup_id match up against each other. The starters is in an ordered list of player_ids, and players is a list of all player_ids in this matchup. The bench can be deduced by removing the starters from the players field.
         * @summary Getting matchups in a league
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} week The week these matchups take place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdMatchupsWeekGet(leagueId: string, week: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Matchup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdMatchupsWeekGet(leagueId, week, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all rosters in a league.
         * @summary Getting rosters in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdRostersGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Roster>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdRostersGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get traded picks
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdTradedPicksGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradedPick>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdTradedPicksGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Get Transactions
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} round The week you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdTransactionsRoundGet(leagueId: string, round: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdTransactionsRoundGet(leagueId, round, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all users in a league. This also includes each users display_name, avatar, and their metadata which sometimes includes a nickname they gave their team.
         * @summary Getting users in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdUsersGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInLeague>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdUsersGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the winners playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leagueLeagueIdWinnersBracketGet(leagueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leagueLeagueIdWinnersBracketGet(leagueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get NFL State
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stateSportGet(sport: 'nfl' | 'nba' | 'lcs', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SportState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stateSportGet(sport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This endpoint retrieves all leagues.
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUserIdLeaguesSportSeasonGet(userId: string, sport: string, season: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<League>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUserIdLeaguesSportSeasonGet(userId, sport, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeaguesApi - factory interface
 * @export
 */
export const LeaguesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaguesApiFp(configuration)
    return {
        /**
         * This endpoint retrieves all leagues.
         * @summary Get a specific league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdGet(leagueId: string, options?: any): AxiosPromise<League> {
            return localVarFp.leagueLeagueIdGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the loosers playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdLosesBracketGet(leagueId: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.leagueLeagueIdLosesBracketGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all matchups in a league for a given week. Each object in the list represents one team. The two teams with the same matchup_id match up against each other. The starters is in an ordered list of player_ids, and players is a list of all player_ids in this matchup. The bench can be deduced by removing the starters from the players field.
         * @summary Getting matchups in a league
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} week The week these matchups take place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdMatchupsWeekGet(leagueId: string, week: number, options?: any): AxiosPromise<Array<Matchup>> {
            return localVarFp.leagueLeagueIdMatchupsWeekGet(leagueId, week, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all rosters in a league.
         * @summary Getting rosters in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdRostersGet(leagueId: string, options?: any): AxiosPromise<Array<Roster>> {
            return localVarFp.leagueLeagueIdRostersGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get traded picks
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdTradedPicksGet(leagueId: string, options?: any): AxiosPromise<Array<TradedPick>> {
            return localVarFp.leagueLeagueIdTradedPicksGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Get Transactions
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {number} round The week you want to pull from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdTransactionsRoundGet(leagueId: string, round: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.leagueLeagueIdTransactionsRoundGet(leagueId, round, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all users in a league. This also includes each users display_name, avatar, and their metadata which sometimes includes a nickname they gave their team.
         * @summary Getting users in a league
         * @param {string} leagueId the league to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdUsersGet(leagueId: string, options?: any): AxiosPromise<Array<UserInLeague>> {
            return localVarFp.leagueLeagueIdUsersGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
         * @summary Getting the winners playoff bracket
         * @param {string} leagueId The ID of the league to retrieve matchups from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leagueLeagueIdWinnersBracketGet(leagueId: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.leagueLeagueIdWinnersBracketGet(leagueId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves all traded picks in a league, including future picks.
         * @summary Get NFL State
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stateSportGet(sport: 'nfl' | 'nba' | 'lcs', options?: any): AxiosPromise<SportState> {
            return localVarFp.stateSportGet(sport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This endpoint retrieves all leagues.
         * @param {string} userId the user is to get
         * @param {string} sport Only \&quot;nfl\&quot; is supported right now
         * @param {number} season The NFL season to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdLeaguesSportSeasonGet(userId: string, sport: string, season: number, options?: any): AxiosPromise<Array<League>> {
            return localVarFp.userUserIdLeaguesSportSeasonGet(userId, sport, season, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaguesApi - object-oriented interface
 * @export
 * @class LeaguesApi
 * @extends {BaseAPI}
 */
export class LeaguesApi extends BaseAPI {
    /**
     * This endpoint retrieves all leagues.
     * @summary Get a specific league
     * @param {string} leagueId the league to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
     * @summary Getting the loosers playoff bracket
     * @param {string} leagueId The ID of the league to retrieve matchups from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdLosesBracketGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdLosesBracketGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all matchups in a league for a given week. Each object in the list represents one team. The two teams with the same matchup_id match up against each other. The starters is in an ordered list of player_ids, and players is a list of all player_ids in this matchup. The bench can be deduced by removing the starters from the players field.
     * @summary Getting matchups in a league
     * @param {string} leagueId The ID of the league to retrieve matchups from
     * @param {number} week The week these matchups take place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdMatchupsWeekGet(leagueId: string, week: number, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdMatchupsWeekGet(leagueId, week, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all rosters in a league.
     * @summary Getting rosters in a league
     * @param {string} leagueId the league to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdRostersGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdRostersGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all traded picks in a league, including future picks.
     * @summary Get traded picks
     * @param {string} leagueId The ID of the league to retrieve matchups from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdTradedPicksGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdTradedPicksGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
     * @summary Get Transactions
     * @param {string} leagueId The ID of the league to retrieve matchups from
     * @param {number} round The week you want to pull from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdTransactionsRoundGet(leagueId: string, round: number, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdTransactionsRoundGet(leagueId, round, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all users in a league. This also includes each users display_name, avatar, and their metadata which sometimes includes a nickname they gave their team.
     * @summary Getting users in a league
     * @param {string} leagueId the league to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdUsersGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdUsersGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves the playoff bracket for a league for 4, 6, and 8 team playoffs. Each row represents a matchup between 2 teams.
     * @summary Getting the winners playoff bracket
     * @param {string} leagueId The ID of the league to retrieve matchups from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public leagueLeagueIdWinnersBracketGet(leagueId: string, options?: any) {
        return LeaguesApiFp(this.configuration).leagueLeagueIdWinnersBracketGet(leagueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves all traded picks in a league, including future picks.
     * @summary Get NFL State
     * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public stateSportGet(sport: 'nfl' | 'nba' | 'lcs', options?: any) {
        return LeaguesApiFp(this.configuration).stateSportGet(sport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This endpoint retrieves all leagues.
     * @param {string} userId the user is to get
     * @param {string} sport Only \&quot;nfl\&quot; is supported right now
     * @param {number} season The NFL season to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaguesApi
     */
    public userUserIdLeaguesSportSeasonGet(userId: string, sport: string, season: number, options?: any) {
        return LeaguesApiFp(this.configuration).userUserIdLeaguesSportSeasonGet(userId, sport, season, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Please use this call sparingly, as it is intended only to be used once per day at most to keep your player IDs updated. The average size of this query is 5MB. <br/> Since rosters and draft picks contain Player IDs which look like \"1042\", \"2403\", \"CAR\", etc, you will need to know what those IDs map to. The /players call provides you the map necessary to look up any player. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Fetch all players
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersNflGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/players/nfl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please give attribution to Sleeper you are using our trending data. If you\'d like to embed our trending list on your website or blog, please use the embed code on the right. <br/> You can use this endpoint to get a list of trending players based on adds or drops in the past 24 hours. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Trending Players
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {'add' | 'drop'} type Either add or drop
         * @param {string} [lookbackHours] Number of hours to look back (default is 24) - optional
         * @param {string} [limit] Number of results you want, (default is 25) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersSportTrendingTypeGet: async (sport: 'nfl' | 'nba' | 'lcs', type: 'add' | 'drop', lookbackHours?: string, limit?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sport' is not null or undefined
            assertParamExists('playersSportTrendingTypeGet', 'sport', sport)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('playersSportTrendingTypeGet', 'type', type)
            const localVarPath = `/players/{sport}/trending/{type}`
                .replace(`{${"sport"}}`, encodeURIComponent(String(sport)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lookbackHours !== undefined) {
                localVarQueryParameter['lookback_hours'] = lookbackHours;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * Please use this call sparingly, as it is intended only to be used once per day at most to keep your player IDs updated. The average size of this query is 5MB. <br/> Since rosters and draft picks contain Player IDs which look like \"1042\", \"2403\", \"CAR\", etc, you will need to know what those IDs map to. The /players call provides you the map necessary to look up any player. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Fetch all players
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playersNflGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Player; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playersNflGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Please give attribution to Sleeper you are using our trending data. If you\'d like to embed our trending list on your website or blog, please use the embed code on the right. <br/> You can use this endpoint to get a list of trending players based on adds or drops in the past 24 hours. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Trending Players
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {'add' | 'drop'} type Either add or drop
         * @param {string} [lookbackHours] Number of hours to look back (default is 24) - optional
         * @param {string} [limit] Number of results you want, (default is 25) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playersSportTrendingTypeGet(sport: 'nfl' | 'nba' | 'lcs', type: 'add' | 'drop', lookbackHours?: string, limit?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrendingPlayer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playersSportTrendingTypeGet(sport, type, lookbackHours, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         * Please use this call sparingly, as it is intended only to be used once per day at most to keep your player IDs updated. The average size of this query is 5MB. <br/> Since rosters and draft picks contain Player IDs which look like \"1042\", \"2403\", \"CAR\", etc, you will need to know what those IDs map to. The /players call provides you the map necessary to look up any player. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Fetch all players
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersNflGet(options?: any): AxiosPromise<{ [key: string]: Player; }> {
            return localVarFp.playersNflGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Please give attribution to Sleeper you are using our trending data. If you\'d like to embed our trending list on your website or blog, please use the embed code on the right. <br/> You can use this endpoint to get a list of trending players based on adds or drops in the past 24 hours. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
         * @summary Trending Players
         * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
         * @param {'add' | 'drop'} type Either add or drop
         * @param {string} [lookbackHours] Number of hours to look back (default is 24) - optional
         * @param {string} [limit] Number of results you want, (default is 25) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playersSportTrendingTypeGet(sport: 'nfl' | 'nba' | 'lcs', type: 'add' | 'drop', lookbackHours?: string, limit?: string, options?: any): AxiosPromise<Array<TrendingPlayer>> {
            return localVarFp.playersSportTrendingTypeGet(sport, type, lookbackHours, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * Please use this call sparingly, as it is intended only to be used once per day at most to keep your player IDs updated. The average size of this query is 5MB. <br/> Since rosters and draft picks contain Player IDs which look like \"1042\", \"2403\", \"CAR\", etc, you will need to know what those IDs map to. The /players call provides you the map necessary to look up any player. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
     * @summary Fetch all players
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersNflGet(options?: any) {
        return PlayersApiFp(this.configuration).playersNflGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please give attribution to Sleeper you are using our trending data. If you\'d like to embed our trending list on your website or blog, please use the embed code on the right. <br/> You can use this endpoint to get a list of trending players based on adds or drops in the past 24 hours. <br/> You should save this information on your own servers as this is not intended to be called every time you need to look up players due to the filesize being close to 5MB in size. You do not need to call this endpoint more than once per day. 
     * @summary Trending Players
     * @param {'nfl' | 'nba' | 'lcs'} sport nfl, nba, lcs, etc
     * @param {'add' | 'drop'} type Either add or drop
     * @param {string} [lookbackHours] Number of hours to look back (default is 24) - optional
     * @param {string} [limit] Number of results you want, (default is 25) - optional
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playersSportTrendingTypeGet(sport: 'nfl' | 'nba' | 'lcs', type: 'add' | 'drop', lookbackHours?: string, limit?: string, options?: any) {
        return PlayersApiFp(this.configuration).playersSportTrendingTypeGet(sport, type, lookbackHours, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update an existing pet
         * @param {string} userId The id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdGet: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userUserIdGet', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {string} username The username to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameGet: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUsernameGet', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update an existing pet
         * @param {string} userId The id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUserIdGet(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUserIdGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user information
         * @param {string} username The username to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUsernameGet(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUsernameGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Update an existing pet
         * @param {string} userId The id of the user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdGet(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.userUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user information
         * @param {string} username The username to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUsernameGet(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.userUsernameGet(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Update an existing pet
     * @param {string} userId The id of the user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUserIdGet(userId: string, options?: any) {
        return UserApiFp(this.configuration).userUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user information
     * @param {string} username The username to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUsernameGet(username: string, options?: any) {
        return UserApiFp(this.configuration).userUsernameGet(username, options).then((request) => request(this.axios, this.basePath));
    }
}


